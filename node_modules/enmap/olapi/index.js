const request = require('snekfetch');
const { promisify } = require('util');

const btoa = str => Buffer.from(str).toString('base64');
const timeout = promisify(setTimeout);

/**
 * Olapi is a node.js wrapper around Objectif Lune's OL Connect REST API.
 * It attempts to make processing data mapping and output tasks quickly and 
 * effectively and provides helper methods to greatly simplify interacting with the API for simple and complex tasks.
 * @constructor
 */
class OLAPI {

  /**
   * Initializes a link to the Objectif Lune REST API
   * @param {APIOptions} options - Optional parameters to initialize the connection.
   */
  constructor(options) {
    console.log(options);
    if (!options) throw new Error('options is a required attribute');
    if (!options.username) this.username = 'ol-admin';
    if (!options.password) this.password = 'secret';
    if (!options.baseurl) this.baseurl = 'http://localhost:9340';
    this.keepalive = options.keepalive || true;
    this.keepaliveTimeout = options.keepaliveTimeout || 60 * 60 * 1000;
    this.checkAuth();
  }

  /** 
  * Makes a request to the Rest API address with the specified method and data.
  * @param {string} uri - The URI part where the request is made.
  * @param {string} method - The method (GET, POST, etc) for the request.
  * @param {Object} data - An object containing extra data, such as file attachments.
  * @return {Promise}
  */
  async _makeRequest(uri, method, data = {}) {
    await this.checkAuth();
    const req = request[method](`${this.baseurl}/rest/serverengine${uri}`);
    req.set('auth_token', this.APIKey);

    if (method === 'post') {
      req.set('Content-Type', data.type || 'application/octet-stream');
      return req.send(data.file);
    }

    // .send() might be optional as it's awaited by default
    return req.send();
  }

  /**
   * Keeps authentication alive through a timer. If any action is taken the timer resets, as
   * the server itself keeps auth alive. Otherwise, grabs a new key.
   */
  async checkAuth() {
    if (!this.alive) {
      const req = await request.post(`${this.baseurl}/rest/serverengine/authentication/login`)
        .set('Authorization', btoa('ol-admin:secret'))
        .send();
      this.APIKey = req.text;
      console.log(`Current API Key: ${this.APIKey}`);
    }
    this.alive = setTimeout(() => {
      this.alive = null;
      if (this.keepalive)
        this.checkAuth();
    }, this.keepaliveTimeout);
  }

  /** ************************************************
   *           FILE STORE SERVICE METHODS            *
   ************************************************* */

  /**
   * Fetches the version of the Connect Server used by the API.
   * @return {Promise<string>} - Connect Server Version.
   */
  async fetchServiceVersion() {
    const serviceInfo = await this._makeRequest('/authentication/version', 'get');
    return serviceInfo.text;
  }

  /**
   * Uploads a data file to the REST API
   * Must be a valid FileStream, use `fs.readFileStream()` to obtain it.
   * @param {FileStream} file - A valid Octect Stream.
   * @param {string} filename - The filename as stored in the repository.
   * @param {boolean} persistent - Whether to save the file in the persistent File Store.
   * @return {Promise<string>} - The Data File ID returned by the REST API.
   */
  async uploadDataFile(file, filename, persistent = false) {
    const res = await this._makeRequest(`/filestore/DataFile?persistent=${persistent}&filename=${encodeURIComponent(filename)}`, 'post', {
      filename,
      file,
      type: 'application/octet-stream',
    });
    return res.text;
  }

  /**
   * Uploads a data mapping configuration (.ol-datamapper) to the REST API.
   * Must be a valid FileStream, use `fs.readFileStream()` to obtain it.
   * @param {FileStream} dmConfig - A valid Octect Stream of a data mapping configuration.
   * @param {boolean} persistent - Whether to save the file in the persistent File Store.
   * @return {Promise<string>} - The Data Mapping ID returned by the REST API.
   */
  async uploadDataMapper(dmConfig, persistent = false) {
    const res = await this._makeRequest(`/filestore/DataMiningConfig?persistent=${persistent}`, 'post', {
      filename: 'config.ol-dmconfig', file: dmConfig, type: 'application/octet-stream',
    });
    return res.text;
  }

  /**
   * Uploads a template (.ol-template) to the REST API.
   * Must be a valid FileStream, use `fs.readFileStream()` to obtain it.
   * @param {FileStream} template - A valid Octect Stream of a template file.
   * @param {boolean} persistent - Whether to save the file in the persistent File Store.
   * @return {Promise<string>} - The Template ID returned by the REST API.
   */
  async uploadTemplate(template, persistent = false) {
    console.log(`Attempting to upload template`);
    const res = await this._makeRequest(`/filestore/template?persistent=${persistent}`, 'post', {
      filename: 'template.ol-template', file: template, type: 'application/zip',
    });
    return res.text;
  }

  /**
   * Uploads a Job Creation Preset to the REST API.
   * @param {FileStream} jobPreset - A valid Job Creation Preset.
   * @param {boolean} persistent - Whether to save the file in the persistent File Store.
   * @return {Promise<string>} - The Job Preset ID returned by the REST API.
   */
  async uploadJobPreset(jobPreset, persistent = false) {
    const res = await this._makeRequest(`/filestore/JobCreationConfig?persistent=${persistent}`, 'post', {
      filename: 'preset.ol-jobpreset', file: jobPreset, type: 'application/xml',
    });
    return res.text;
  }

  /**
   * Uploads a Ouput Creation Preset to the REST API.
   * @param {FileStream} outputPreset - A valid Ouput Creation Preset.
   * @param {boolean} persistent - Whether to save the file in the persistent File Store.
   * @return {Promise<string>} - The Ouput Preset ID returned by the REST API.
   */
  async uploadOuputPreset(outputPreset, persistent = false) {
    const res = await this._makeRequest(`/filestore/OutputCreationConfig?persistent=${persistent}`, 'post', {
      filename: 'preset.ol-outputpreset', file: outputPreset, type: 'application/xml',
    });
    return res.text;
  }

  /**
   * Deletes a managed file 
   * @param {string|Integer} id - The ID of the managed file on the Connect Server.
   * @return {Promise<string>} - The result of the deletion operation.
   */
  async deleteManagedData(id) {
    const res = await this._makeRequest(`/filestore/delete/${id}`, 'get');
    return res.text;
  }

  /**
   * Fetches any file from the File Store
   * @param {string|Integer} id - The ID of a managed file on the Connect Server
   * @return {Buffer|string} - The managed file, or an error given while attempting to retrieve it.
   */
  async fetchManagedFile(id) {
    const res = await this._makeRequest(`/filestore/file/${id}`, 'get');
    return res.body;
  }

  /** ************************************************
   *          DATA MAPPING SERVICE METHODS           *
   ************************************************* */


  /**
   * Starts the execution of a data mapping operation on the REST API.
   * @param {DataMapperOptions} options - A JavaScript Object containing all the options necessary for dataMapping
   * @return {Promise<string>} - The Operation ID needed to query startDataMapping, awaitDMAction and getRecords.
   */
  async startDataMapping(options) {
    if (!options.json && !options.pdfvt && !options.dataFileID) throw new Error(`Must provide either json, pdfvt or dataFileID option as data mapping source`);
    let url;
    let data;
    if (options.json) {
      if (!options.dmID) throw new Error(`Must provide options.dmID for processing a data mapping configuration`);
      url = `/workflow/datamining/${options.dmID}`;
      data = options.json;
    } else
    if (options.dataFileID) {
      if (!options.dmID) throw new Error(`Must provide options.dmID for processing a data mapping configuration`);
      url = `/workflow/datamining/${options.dmID}/${options.dataFileID}`;
    } else
    if (options.pdfvt) {
      url = `/workflow/datamining/${options.dataSet ? `pdfvtds` : `pdfvtcs`}/${options.pdfvt}`;
    }
    const operationResp = await this._makeRequest(url, 'post', data);
    return operationResp.headers.operationid;
  }

  /**
   * Fetches all current operations.
   * @return {Promise<Object>} - 
   */
  async fetchOperations() {
    const response = await this._makeRequest(`/workflow/datamining/getOperations`, 'get');
    return response.body;
  }

  /**
   * Cancels a running operation.
   * @param {string|Integer} operationID - A valid, current operation ID.
   * @return {Promise<string>} - The response from the cancel operation.
   */
  async cancelOperation(operationID) {
    const response = await this._makeRequest(`/workflow/datamining/cancel/${operationID}`, 'post');
    return response.body;
  }

  /**
   * Waits for a data mapping operation to finish. Either await this, or use .then() to wait for the operation to complete.
   * @param {string|Integer} operationID - A valid, current operation ID.
   * @return {Promise<string>}
   */
  async awaitDMAction(operationID) {
    const resp = await this._makeRequest(`/workflow/datamining/getProgress/${operationID}`, 'get');
    if (resp.text === 'done') return true;
    await timeout(100);
    return this.awaitDMAction(operationID);
  }

  async fetchDataSetResult(operationID) {
    const dataSet = await this._makeRequest(`/workflow/datamining/getResult/${operationID}`, 'post');
    return dataSet.text;
  }

  async fetchDataSetIDs(dataSetID) {
    const identifiers = await this._makeRequest(`/entity/datasets/${dataSetID}`, 'get');
    return JSON.parse(identifiers.text).identifiers;
  }

  /* ************************************************
   *           CONTENT CREATION METHOD              *
   ************************************************ */

  async startContentCreation(options) {
    if (!options.json && !options.templateID) throw new Error(`Invalid options provided.`);
    let url;
    let data;
    if (options.json) {
      if (!options.templateID) throw new Error(`Must provide options.templateID for content creation using JSON.`);
      url = `/workflow/contentcreation/${options.templateID}`;
      data = options.json;
    } else
    if (options.dataSetID) {
      if (!options.templateID) throw new Error(`Must provide options.templateID for content creation`);
      url = `/workflow/contentcreation/${options.templateID}/${options.dataSetID}`;
    }
    const operationResp = await this._makeRequest(url, 'post', data);
    return operationResp.headers.operationid;
  }

  async startDataRecordPreview(recordID, templateID) {
    const response = await this._makeRequest(`/workflow/contentcreation/pdfpreviewdirect/?templateId=${templateID}&dataRecordId=${recordID}`, 'get');
    return response.text;
  }

  async startPDFPreview(options) {
    if (!options.templateID) throw new Error(`Must provide options.templateID for PDF Preview`);
    let url;
    const data = {};
    if (options.json) {
      url = `/workflow/contentcreation/pdfpreview/${options.templateID}`;
      data.file = options.json;
      data.type = 'application/json';
    } else
    if (options.dmID) {
      url = `/workflow/contentcreation/pdfpreview/${options.templateID}/${options.dmID}`;
    } else {
      throw new Error(`Invalid options provided.`);
    }
    const response = await this._makeRequest(url, 'post', data);
    return response.text;
  }

  async fetchContentCreationOperations() {
    const response = await this._makeRequest(`/workflow/contentcreation/getOperations`, 'get');
    return response.body;
  }

  /**
   * Waits for a content creation operation to finish. Either await this, or use .then() to wait for the operation to complete.
   * @param {string|Integer} operationID - A valid, current operation ID.
   * @return {Promise<string>}
   */
  async awaitContentCreation(operationID) {
    const resp = await this._makeRequest(`/workflow/contentcreation/getProgress/${operationID}`, 'get');
    if (resp.text === 'done') return true;
    await timeout(100);
    return this.awaitContentCreation(operationID);
  }

  async fetchContentItems(operationID) {
    const dataSet = await this._makeRequest(`/workflow/contentcreation/getResult/${operationID}`, 'post');
    const identifiers = await this._makeRequest(`/workflow/contentcreation/getResult/${dataSet.text}`, 'get');
    return JSON.parse(identifiers.text).identifiers;
  }

  /* ************************************************
   *             CONTENT ITEM METHODS               *
   ************************************************ */

  /**
    * Fetches the Record ID used to generate a specific Content Item
    * @param {string|Integer} id - The ID of the content item to fetch the record ID from.
    * @return {Promise<string>} - The ID of the record, if the Content Item was found.
    */
  async fetchRecordFromContentItem(id) {
    const response = await this._makeRequest(`/entity/contentitems/${id}/datarecord`, 'get');
    return JSON.parse(response.text);
  }

  /**
   * Fetches the properties of a Content Item.
   * @param {string|Integer} id - The ID of the content item.
   * @return {Promise<Object>} - An Object containing the Content Item Properties.
   */
  async fetchContentItemProperties(id) {
    const response = await this._makeRequest(`/entity/contentitems/${id}/properties`, 'get');
    return JSON.parse(response.text);
  }

  /**
   * Modifies the properties of a Content Item.
   * @param {string|Integer} id - The ID of the content item.
   * @param {Object} values - An object containing a key/value pair of properties to change.
   * @return {Promise<string>} The server's response.
   */
  async updateContentItem(id, values) {
    /* TODO: support multiple IDs after figuring out what data it expects. 
    http://help.objectiflune.com/en/planetpress-connect-rest-api-cookbook/1.7/#Cookbook/REST_API_Reference/Content_Item_Entity_Service/Update_Multiple_Content_Item_Properties.htm */
    if (!values || typeof values !== object) throw new Error('Must provide values object.');
    const response = await this._makeRequest(`/entity/contentitems/${id}/properties`, 'put', values);
    return response.text;
  }

  /* ************************************************
   *             CONTENT SET METHODS                *
   ************************************************ */

  async fetchContentSetItems(id) {
    const response = await this._makeRequest(`/entity/contentsets/${id}`, 'get');
    return response.body;
  }

  async fetchContentSetPages(id) {
    const response = await this._makeRequest(`/entity/contentsets/${id}/pages`, 'get');
    return response.body;
  }

  async fetchContentSetProperties(id) {
    const response = await this._makeRequest(`/entity/contentsets/${id}/properties`, 'get');
    return response.body;
  }

  async updateContentSet(id, values) {
    /* TODO: support multiple IDs after figuring out what data it expects. 
    http://help.objectiflune.com/en/planetpress-connect-rest-api-cookbook/1.7/#Cookbook/REST_API_Reference/Content_Set_Entity_Service/Update_Content_Set_Properties.htm */
    if (!values || typeof values !== 'object') throw new Error('Must provide values object.');
    const response = await this._makeRequest(`/entity/contentsets/${id}/properties`, 'put', values);
    return response.text;
  }

  async deleteContentSet(id) {
    const response = await this._makeRequest(`/entity/contentsets/${id}/delete`, 'post');
    return response.body;
  }

  /* ************************************************
   *             DATA RECORD METHODS                *
   ************************************************ */

  async addDataRecords() {
    // to be done.
    // http://help.objectiflune.com/en/planetpress-connect-rest-api-cookbook/1.7/Content/Cookbook/REST_API_Reference/Data_Record_Entity_Service/Add_Data_Records.htm
  }

  /**
   * Fetches record data 
   * @param {Array|string|Integer} ids - A single ID or array of IDs to fetch the data for.
   * @param {boolean} recursive - Whether to return all sub-tables (detail tables and nested tables) for each record.
   * @return {Promise<Object>} - An Object containing the record data for the requested ID(s).
   */
  async fetchRecordData(ids, recursive = false) {
    let uri;
    if (typeof ids === 'string' || Number.isInteger(ids))
      uri = `/entity/datarecords/${ids}/values?recursive=${recursive}`;
    else
      uri = `/entity/datarecords/values?recursive=${recursive}${ids.map(id => `id=${id}`).join('&')}`;

    const fullData = await this._makeRequest(uri, 'get');
    return JSON.parse(fullData.text);
  }

  async fetchRecordProperties(id) {
    const response = this._makeRequest(`/entity/datarecords/${id}/properties`, 'get');
    return response.body;
  }

  async updateDataRecord(id, data) {
    /* TODO: support multiple IDs after figuring out what data it expects. 
    http://help.objectiflune.com/en/planetpress-connect-rest-api-cookbook/1.7/Content/Cookbook/REST_API_Reference/Data_Record_Entity_Service/Update_Data_Record_Values.htm */
    const response = this._makeRequest(`/entity/datarecords/${id}/values`, 'put', data);
    return response.body;
  }

  async updateDataRecordProperties(id, data) {
    const response = this._makeRequest(`/entity/datarecords/${id}/properties`, 'put', data);
    return response.body;
  }

  /* ************************************************
   *              DOCUMENT METHODS                  *
   ************************************************ */

  async fetchDocumentProperties(id) {
    const response = this._makeRequest(`/entity/documents/${id}/metadata`, 'get');
    return response.body;
  }

  async updateDocumentProperties(id, data) {
    const response = this._makeRequest(`/entity/documents/${id}/metadata`, 'put', data);
    return response.body;
  }

  async getDocumentSet(id) {
    const response = this._makeRequest(`/entity/documentsets/${id}`, 'get');
    return response.body;
  }

  async getDocumentSetProperties(id) {
    const response = this._makeRequest(`/entity/documentsets/${id}/metadata`, 'get');
    return response.body;
  }

  async updateDocumentSetProperties(id, data) {
    const response = this._makeRequest(`/entity/documentsets/${id}/metadata`, 'put', data);
    return response.body;
  }

  /* ************************************************
   *    HELPER METHODS THAT CALL OTHER METHODS      *
   ************************************************ */

  /**
   * Does a complete data mapping operation from upload through return of the full record data.
   * Shortcut to calling each method in the process yourself, but does not provide IDs for further use.
   * @param {FileStream} dataFile - A File Stream of a PDF file.
   * @param {FileStream} dmConfig - A File Stream of a data mapping configuration.
   * @param {boolean} recursive - Whether to return all sub-tables (detail tables and nested tables) for each record.
   * @return {Promise<Object>} - A JSON object containing the record data for the requested ID(s).
   */
  async recordFromFiles(dataFile, dmConfig, recursive = false) {
    const dataFileID = await this.uploadDataFile(dataFile);
    const dmID = await this.uploadDataMapper(dmConfig);
    const operationID = await this.startDataMapping({ dmID, dataFileID });
    await this.awaitDMAction(operationID);

    const dataSetID = await this.fetchDataSetResult(operationID);
    const dataSet = await this.fetchDataSetIDs(dataSetID);
    return this.fetchRecordData(dataSet, recursive);
  }

  async contentItemFromRecordSet(dataSetID, templateFile) {
    const templateID = await this.uploadTemplate(templateFile);
    const operationID = await this.startContentCreation({ templateID, dataSetID });
    await this.awaitContentCreation(operationID);
    // finish this.
  }

  async json2pdf(json, templateFile) {
    const templateID = await this.uploadTemplate(templateFile);
    console.log(`Template ID: ${templateID}`);
    const managedFileID = await this.startPDFPreview({ json, templateID });
    console.log(`PDF Created. Managed File ID: ${managedFileID}`);
    return this.fetchManagedFile(managedFileID);
  }

}

module.exports = OLAPI;
module.exports.TypeDefs = {
/**
 * 
 * @typedef {Object} APIOptions
 * @property {string} [username = "ol-admin"] - The Username set in the OL Connect Server' security dialog.
 * @property {string} [password = "secret"] - The Password set in the OL Connect Server' security dialog.
 * @property {string} [baseurl = "http://localhost:9340"] - The URL of the OL Connect Server REST API. Must accept incoming connections through the defined port. 
 * @property {boolean} [keepalive = true] - Whether to maintain an open connection at all times. Useful for very active systems.
 * @property {int} [keepaliveTimeout = 36000000] - Delay after the last query to reset the connection (defaults to 60 minutes on the server).
 */

/**
 * @typedef {Object} DataMapperOptions
 * @property {Object|string<json>} json - To create records directly from an object, provide an object or JSON string as well as dmID.
 * @property {string} pdfvt - To create records from a PDF/VT, provide the ID of an uploaded PDF/VT data file. 
 * @property {string} dataFileID - To create records from a data file, provide the ID of an uploaded data file.
 * @property {string} dmID - Optional if using a PDF/VT file. The ID of an uploaded data mapper file.
 * @property {string} dataSet - If creating records from a PDF/VT, setting this to `true` returns a dataSet. Otherwise, returns a Content Set.
 */
};
